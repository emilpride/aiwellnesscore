<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Wellness Analysis - Final Polished Version</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://js.stripe.com/v3/"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core/dist/tf-core.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter/dist/tf-converter.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl/dist/tf-backend-webgl.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --brand-accent: #debea9;
            --brand-dark-text: #3c3b31;
        }
        html, body { overscroll-behavior: none; font-family: 'Inter', sans-serif; }
        body { background-color: #f3f4f6; }
        #quiz-container { display: flex; flex-direction: column; position: relative; width: 100vw; height: 100vh; height: calc(var(--vh, 1vh) * 100); overflow: hidden; }
        main#steps-wrapper { position: relative; width: 100%; flex-grow: 1; overflow: hidden; }
        .quiz-step {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 1rem; background-color: transparent;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s ease-out;
            opacity: 1; overflow-y: auto;
        }
        .quiz-step:not(.active) { opacity: 0; pointer-events: none; transform: translateX(30px) scale(0.98); }
        .quiz-step.active { transform: translateX(0) scale(1); }
        .quiz-step.prev { transform: translateX(-30px) scale(0.98); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.5s ease-out forwards; }
        .answer-option { transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease; }
        .answer-option:hover { transform: translateY(-5px); box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
        .answer-option.selected { transform: translateY(-5px) scale(1.02); border-color: var(--brand-accent); box-shadow: 0 0 20px rgba(222, 190, 169, 0.6); }

        /* --- СТИЛИ КАМЕРЫ И AR --- */
        #camera-modal { position: fixed; inset: 0; background-color: rgba(0,0,0,0.8); z-index: 100; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; backdrop-filter: blur(5px); }
        #camera-modal.active { opacity: 1; pointer-events: all; }
        #camera-container { position: relative; width: 90%; max-width: 400px; aspect-ratio: 3/4; overflow: hidden; border-radius: 1.5rem; background: #111; border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; }
        #camera-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #camera-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        #camera-guide-overlay {
            position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5); text-align: center;
        }
        #camera-guide-box {
            width: 70%; aspect-ratio: 1/1.2; border: 2px dashed rgba(255,255,255,0.5); border-radius: 50%;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #camera-guide-box.locked {
            border-color: #34d399;
            box-shadow: 0 0 20px #34d399;
        }
        #camera-countdown { font-size: 5rem; font-weight: 800; position: absolute; }
        #capture-btn {
            width: 70px; height: 70px; border-radius: 50%; background-color: rgba(255,255,255,0.9);
            border: 4px solid white; box-shadow: 0 0 0 5px rgba(255,255,255,0.3); cursor: pointer;
            transition: transform 0.2s; position: absolute; bottom: 1.5rem; display: flex; align-items: center; justify-content: center;
        }
        #capture-btn::before {
            content: ''; width: 24px; height: 24px; border-radius: 50%; background-color: #ef4444; transition: all 0.2s;
        }
        #capture-btn:hover::before { transform: scale(1.2); }

        /* --- ИСПРАВЛЕННЫЕ СТИЛИ АНИМАЦИИ СТРЕССА --- */
        @keyframes breathe {
            0%, 100% { transform: scale(0.9); box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.1); }
            50% { transform: scale(1); box-shadow: 0 0 20px 10px rgba(0, 0, 0, 0.05); }
        }
        .stress-breather {
            width: 120px; height: 120px; margin: 1rem auto; border-radius: 50%;
            animation-name: breathe;
            animation-iteration-count: infinite;
            /* ОШИБКА БЫЛА ЗДЕСЬ: transition не может анимировать animation-duration. Просто убираем его. */
            transition: background-color 1s ease;
        }
        
        /* Остальные стили для виджетов, профиля и т.д. */
        .widget-wrapper { background-color: #fff; padding: 1.5rem; border-radius: 1.5rem; box-shadow: 0 4px 10px rgba(0,0,0,0.03); border: 1px solid #f3f4f6; width: 100%; max-width: 320px; text-align: center; }
        .widget-label { font-weight: 600; color: #4b5563; margin-bottom: 1rem; }
        .bmi-gauge-bg { fill: none; stroke: #e5e7eb; }
        .bmi-gauge-fg { fill: none; stroke: url(#bmi-gradient); stroke-linecap: round; transition: stroke-dashoffset 1.5s cubic-bezier(0.4, 0, 0.2, 1); }
        .sleep-ring-bg { stroke: #e5e7eb; }
        .sleep-ring-fg { stroke: #818cf8; stroke-linecap: round; transform: rotate(-90deg); transform-origin: 50% 50%; transition: stroke-dashoffset 1.5s cubic-bezier(0.4, 0, 0.2, 1); }
        .activity-week { display: flex; justify-content: space-around; gap: 8px; }
        .activity-day { width: 36px; height: 36px; border-radius: 10px; background-color: #e5e7eb; color: #6b7280; font-weight: 700; display: flex; align-items: center; justify-content: center; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .activity-day.active { background-color: var(--brand-accent); color: var(--brand-dark-text); transform: scale(1.15) translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.1); }
    </style>
</head>
<body>

<div id="quiz-container">
    <main id="steps-wrapper">
        </main>
</div>

<div id="camera-modal">
    <div id="camera-container">
        <video id="camera-video" autoplay playsinline></video>
        <canvas id="camera-canvas"></canvas>
        <div id="camera-guide-overlay">
            <h3 id="camera-guide-text" class="text-lg font-semibold">Расположите лицо в овале</h3>
            <div id="camera-guide-box"></div>
            <div id="camera-countdown"></div>
        </div>
    </div>
</div>
<canvas id="photo-canvas" style="display: none;"></canvas>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // Весь объект App и начальные функции остаются прежними
    const App = {
        currentStep: 0,
        currentQuestionIndex: -1,
        userAnswers: {},
        userPhotoUrl: null,
        biologicalAge: null,
        wellnessScore: null,
        cameraStream: null,
        // --- Новые переменные для AR ---
        faceMesh: null,
        cameraAnimFrame: null,
        countdownTimer: null,
        countdownValue: 3,
        // quizQuestions, testimonials, faq и т.д.
    };
    
    // Все функции до openCamera остаются без изменений
    // ...

    // --- НОВАЯ ЛОГИКА ДЛЯ AR-АНАЛИЗА ЛИЦА ---

    let faceMesh;

    async function initFaceAnalysis() {
        if (faceMesh) return;
        
        faceMesh = new FaceMesh({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }});

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(onFaceResults);
    }

    const videoElement = document.getElementById('camera-video');
    const canvasElement = document.getElementById('camera-canvas');
    const canvasCtx = canvasElement.getContext('2d');

    function onFaceResults(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];
            
            // Рисуем овал-маску
            canvasCtx.beginPath();
            const ovalPoints = [10, 338, 297, 299, 270, 269, 267, 0, 37, 39, 40, 60, 61, 62, 133, 173, 155, 154, 153, 145, 144, 168, 10];
            for(let i = 0; i < ovalPoints.length; i++) {
                const p = landmarks[ovalPoints[i]];
                const x = p.x * canvasElement.width;
                const y = p.y * canvasElement.height;
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
            }
            canvasCtx.closePath();
            canvasCtx.strokeStyle = 'rgba(222, 190, 169, 0.8)';
            canvasCtx.lineWidth = 4;
            canvasCtx.stroke();

            // Проверяем, находится ли лицо в рамке для авто-съемки
            checkFacePosition(landmarks);
        } else {
             resetCountdown();
        }
    }
    
    const guideBox = document.getElementById('camera-guide-box');
    const guideText = document.getElementById('camera-guide-text');
    const countdownText = document.getElementById('camera-countdown');

    function checkFacePosition(landmarks) {
        const nose = landmarks[1]; // Кончик носа
        const left = landmarks[234]; // Левый край лица
        const right = landmarks[454]; // Правый край лица
        const top = landmarks[10]; // Верхняя точка лба
        const bottom = landmarks[152]; // Подбородок

        const faceWidth = Math.abs(right.x - left.x);
        
        // Условия для старта отсчета
        const isCentered = nose.x > 0.3 && nose.x < 0.7 && nose.y > 0.3 && nose.y < 0.7;
        const isGoodSize = faceWidth > 0.3;

        if (isCentered && isGoodSize) {
            if (!App.countdownTimer) {
                startCountdown();
            }
            guideBox.classList.add('locked');
        } else {
            resetCountdown();
        }
    }

    function startCountdown() {
        guideText.textContent = "Не двигайтесь...";
        App.countdownValue = 3;
        countdownText.textContent = App.countdownValue;
        
        App.countdownTimer = setInterval(() => {
            App.countdownValue--;
            countdownText.textContent = App.countdownValue;
            if (App.countdownValue <= 0) {
                clearInterval(App.countdownTimer);
                App.countdownTimer = null;
                capturePhoto();
            }
        }, 1000);
    }

    function resetCountdown() {
        if (App.countdownTimer) {
            clearInterval(App.countdownTimer);
            App.countdownTimer = null;
        }
        guideBox.classList.remove('locked');
        guideText.textContent = "Расположите лицо в овале";
        countdownText.textContent = "";
    }

    async function predictWebcam() {
        if (App.cameraStream && videoElement.readyState >= 3) {
           await faceMesh.send({image: videoElement});
        }
        App.cameraAnimFrame = requestAnimationFrame(predictWebcam);
    }
    
    async function openCamera() {
        const modal = document.getElementById('camera-modal');
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            alert("Camera API is not supported in your browser.");
            return;
        }
        try {
            App.cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 720 }, height: { ideal: 1280 } } });
            videoElement.srcObject = App.cameraStream;
            videoElement.onloadedmetadata = async () => {
                modal.classList.add('active');
                await initFaceAnalysis();
                predictWebcam();
            };
        } catch (err) {
            console.error("Error accessing camera: ", err);
            alert("Could not access the camera. Please ensure you have given permission.");
        }
    }

    function closeCamera() {
        if (App.cameraStream) {
            App.cameraStream.getTracks().forEach(track => track.stop());
            App.cameraStream = null;
        }
        if (App.cameraAnimFrame) {
            cancelAnimationFrame(App.cameraAnimFrame);
            App.cameraAnimFrame = null;
        }
        resetCountdown();
        document.getElementById('camera-modal').classList.remove('active');
    }

    function capturePhoto() {
        // Логика захвата фото остается той же
        const canvas = document.getElementById('photo-canvas');
        const context = canvas.getContext('2d');
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        context.translate(canvas.width, 0);
        context.scale(-1, 1);
        context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg');
        closeCamera();
        handleAnswer('selfie', dataUrl);
    }
    
    // Инициализация и все остальные функции (renderQuestion, playAnimation и т.д.)
    // Важно: playAnimation с исправленной логикой для 'stress_visual'
    function playAnimation(key) {
        // ... (кейсы для bmi, sleep, activity)
        if (key === 'stress_visual') {
            const level = parseInt(App.userAnswers.stress || 5); // From 2 to 8
            const percent = (level - 2) / (8 - 2); // Normalize to 0-1
            
            const breatherEl = document.getElementById('stress-breather-anim');
            const duration = 4 - (percent * 2.5); // Faster for higher stress (4s down to 1.5s)
            
            const blue = [60, 128, 255]; // Calm
            const red = [239, 68, 68]; // Tense
            const color = blue.map((b, i) => Math.round(b + percent * (red[i] - b)));
            
            if (breatherEl) {
                breatherEl.style.animationDuration = `${duration}s`;
                breatherEl.style.backgroundColor = `rgb(${color.join(',')})`;
            }
        }
    }

    // Здесь должны быть все остальные JS-функции из предыдущего ответа
    // ...
});
</script>
</body>
</html>
